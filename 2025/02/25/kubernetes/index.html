<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>豆豆鱼</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="1 kubernetes概念1.1 了解kuberneteskubernetes是Borg的一个开源版本。具有完备的集群管理能力，包括多层次的安全防护和准入机制，多租胡应用支撑能力，透明的服务注册和服务发现机制，内建的智能负载均衡器，强大的故障发现和自我修复能力，服务滚动升级和在线扩容能力，可扩展的资源自动调度机制，以及多粒度的资源配额管理能力，是一个权限的基于容器技术的分布式架构解决方案，并是一">
<meta property="og:type" content="article">
<meta property="og:title" content="豆豆鱼">
<meta property="og:url" content="https://anthonywangjing.github.io/2025/02/25/kubernetes/index.html">
<meta property="og:site_name" content="豆豆鱼">
<meta property="og:description" content="1 kubernetes概念1.1 了解kuberneteskubernetes是Borg的一个开源版本。具有完备的集群管理能力，包括多层次的安全防护和准入机制，多租胡应用支撑能力，透明的服务注册和服务发现机制，内建的智能负载均衡器，强大的故障发现和自我修复能力，服务滚动升级和在线扩容能力，可扩展的资源自动调度机制，以及多粒度的资源配额管理能力，是一个权限的基于容器技术的分布式架构解决方案，并是一">
<meta property="og:locale">
<meta property="og:image" content="https://img30.360buyimg.com/ebookadmin/jfs/t1/137386/4/22021/69441/620eefbcEf18a8ff9/94d73fe5e124a6e0.jpg">
<meta property="og:image" content="https://img30.360buyimg.com/ebookadmin/jfs/t1/176702/25/27579/101563/620eefd4E7619f6d7/7815084c5255236d.jpg">
<meta property="og:image" content="https://img30.360buyimg.com/ebookadmin/jfs/t1/215690/38/12706/79342/620eefbfE1d1a5b92/49a5fa3ffad4407e.jpg">
<meta property="og:image" content="https://img30.360buyimg.com/ebookadmin/jfs/t1/123338/19/22760/116889/620eefc2Ea59edea4/ef896049e835ba6e.jpg">
<meta property="og:image" content="https://img30.360buyimg.com/ebookadmin/jfs/t1/112889/1/22361/210484/620ef00cEff91dafe/af3aff91b8ed5470.jpg">
<meta property="article:published_time" content="2025-02-25T03:25:53.897Z">
<meta property="article:modified_time" content="2024-02-07T02:16:44.049Z">
<meta property="article:author" content="豆豆鱼">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img30.360buyimg.com/ebookadmin/jfs/t1/137386/4/22021/69441/620eefbcEf18a8ff9/94d73fe5e124a6e0.jpg">
  
    <link rel="alternate" href="/My-Blog/atom.xml" title="豆豆鱼" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/My-Blog/favicon.png">
  
  
  
<link rel="stylesheet" href="/My-Blog/css/style.css">

  
    
<link rel="stylesheet" href="/My-Blog/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/My-Blog/" id="logo">豆豆鱼</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/My-Blog/">Home</a>
        
          <a class="main-nav-link" href="/My-Blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/My-Blog/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://anthonywangjing.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-kubernetes" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/My-Blog/2025/02/25/kubernetes/" class="article-date">
  <time class="dt-published" datetime="2025-02-25T03:25:53.897Z" itemprop="datePublished">2025-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-kubernetes概念"><a href="#1-kubernetes概念" class="headerlink" title="1 kubernetes概念"></a>1 kubernetes概念</h2><h3 id="1-1-了解kubernetes"><a href="#1-1-了解kubernetes" class="headerlink" title="1.1 了解kubernetes"></a>1.1 了解kubernetes</h3><p>kubernetes是Borg的一个开源版本。具有完备的集群管理能力，包括多层次的安全防护和准入机制，多租胡应用支撑能力，透明的服务注册和服务发现机制，内建的智能负载均衡器，强大的故障发现和自我修复能力，服务滚动升级和在线扩容能力，可扩展的资源自动调度机制，以及多粒度的资源配额管理能力，是一个权限的基于容器技术的分布式架构解决方案，并是一个完备的分布式系统开发和支撑平台。</p>
<h4 id="1-1-1-基本概念点"><a href="#1-1-1-基本概念点" class="headerlink" title="1.1.1  基本概念点"></a>1.1.1  基本概念点</h4><h5 id="server"><a href="#server" class="headerlink" title="server"></a>server</h5><p>在kubernetes中，Service是分布式集群架构的核心。一个service对象拥有如下关键特征：</p>
<ul>
<li><p>拥有唯一指定的名称(比如mysql-server)</p>
</li>
<li><p>拥有一个虚拟IP地址(ClusterIP地址)和端口号</p>
</li>
<li><p>能够提供某种远程服务能力</p>
</li>
<li><p>能够将客户端对服务的访问请求转发到一组容器应用上。</p>
</li>
</ul>
<p>如果service要提供外网服务，需要指定公共IP和NodePort，或者负载均衡器;</p>
<h5 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h5><p>系统会在Kubernetes集群中的每个Node上打开一个主机的真实端口，这样，能够访问Node的客户端就能通过这个端口访问到内部的Service了</p>
<h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h5><p>Node作为集群中的工作节点，运行真正的应用程序，在Node上Kubernetes管理的最小运行单元是Pod。Node上运行这kubernetes的kubelet,kube-proxy服务进程，这些服务进程负责Pod的创建，启动，监控，重启，销毁，以及实现软件模式的负载均衡》</p>
<p>Node包含的信息：</p>
<ul>
<li><p>Node地址：主机的IP地址，或者Node ID</p>
</li>
<li><p>Node的运行状态：Pending,Running,Terminated三种状态</p>
</li>
<li><p>Node Condition:….</p>
</li>
<li><p>Node系统容量：描述Node可用的系统资源，包括CPU，内存，最大可调度Pod数量等</p>
</li>
<li><p>其他：内核版本号，kubernetes版本等</p>
</li>
</ul>
<p>查看node信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node</span><br></pre></td></tr></table></figure>

<h5 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h5><p>pod是kubernetes最基本的操作单元，包含一个或多个紧密相关的容器，一个pod可以被一个容器化的环境看作应用层的”逻辑宿主机”；一个pod中的多个容器应用通常是紧密耦合的，pod在node上被创建，启动或者销毁；每个pod里运行着一个特殊的被称之为pause的容器，其他容器则为业务容器，这些业务容器共享Pause容器的网络栈和Volume挂载卷，因此他们之间通信和数据交换更为高效，在设计时我们可以充分利用这一特性将一组密切相关的服务进程放入同一个Pod中</p>
<p>同一个Pod里的容器之间仅需通过localhost就能互相通信<br>![](C:\Users\user\Pictures\Camera Roll\pod.jpg)</p>
<p>一个Pod中的应用容器共享同一组资源：</p>
<ul>
<li>PID命名空间：Pod中的不同应用程序可以看到其他应用程序的进程ID；</li>
<li>网络命名空间：Pod中的多个容器能够访问同一个IP和端口范围；</li>
<li>IPC命名空间：Pod中的多个容器能够使用SystemV IPC或POSIX消息队列进行通信；</li>
<li>UTS命名空间：Pod中的多个容器共享一个主机名；</li>
<li>Volumes（共享存储卷）：Pod中的各个容器可以访问在Pod级别定义的Volumes；</li>
</ul>
<p>Pod的生命周期通过Replication Controller来管理；通过模板进行定义，然后分配到一个Node上运行，在Pod所包含容器运行结束后，Pod结束。</p>
<p>Kubernetes为Pod设计了一套独特的网络配置，包括：为每个Pod分配一个IP地址，使用Pod名作为容器间通信的主机名等</p>
<h5 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h5><p>Volume是Pod中能够被多个容器访问的共享目录</p>
<p>Label<br>Label以key&#x2F;value的形式附加到各种对象上，如Pod、Service、RC、Node等，以识别这些对象，管理关联关系等，如Service和Pod的关联关系</p>
<h5 id="RC-Replication-Controller"><a href="#RC-Replication-Controller" class="headerlink" title="RC(Replication Controller)"></a>RC(Replication Controller)</h5><ul>
<li><p>目标Pod的定义</p>
</li>
<li><p>目标Pod需要运行的副本数量</p>
</li>
<li><p>要监控的目标Pod标签(Lable)</p>
</li>
</ul>
<p>Kubernetes通过RC中定义的Lable筛选出对应的Pod实例，并实时监控其状态和数量，如果实例数量少于定义的副本数量（Replicas），则会根据RC中定义的Pod模板来创建一个新的Pod，然后将此Pod调度到合适的Node上启动运行，直到Pod实例数量达到预定目标。</p>
<h4 id="1-1-2-集群类"><a href="#1-1-2-集群类" class="headerlink" title="1.1.2 集群类"></a>1.1.2 集群类</h4><p>集群管理方面，kubernetes将集群中机器划分为一个Master和一些node.在Master上运行着集群管理相关的进程：kube-apiserver,kube-controller-manager和kube-scheduler，这些进程实现了整个集群的资源管理，Pod调度，弹性伸缩，安全控制，系统监控和纠错等管理功能，并且自动完成。Node作为集群中的工作节点，运行着真正的应用程序。在Node上，kubernetes管理的最小运行单元是pod。在Node上运行着kubernetes的kubelet,kube-proxy服务进程，这些进程负责Pod的创建，启动，监控，重启，销毁以及实现软件模式的负载均衡器</p>
<p>集群（Cluster）表示一个有Master和Node组成的Kubernetes集群</p>
<h5 id="1-Master"><a href="#1-Master" class="headerlink" title="1.Master"></a>1.Master</h5><p>​		Master指的是集群控制节点。在每个kubernetes集群中需要一个或一组Master节点，负责整个集群的管理和控制。</p>
<p>Master上运行的关键进程</p>
<ul>
<li><p>Kubernetes API Server(kube-apiserver): 提供HTTP RESTful API接口的主要服务，是Kubernetes里对所有资源进行增，删，改，查等操作</p>
</li>
<li><p>Kubernetes Controller Manager(kube-controller-manager):Kubernetes里所有资源对象的自动化控制中心。</p>
</li>
<li><p>Kubernetes Scheduler(kube-scheduler):负责资源调度（Pod调度）的进程。</p>
</li>
</ul>
<p>另外，在master上通常还需要部署etcd服务</p>
<h5 id="2-Node"><a href="#2-Node" class="headerlink" title="2.Node"></a>2.Node</h5><p>​    Kubernetes 集群中除Master外的其他服务器被称为Node。Node是Kubernetes 集群中的工作负载节点。<br>Node上运行的关键进程</p>
<ul>
<li><p>kubelet:负责Pod对应容器的创建，启停等任务，同时与Master密切协作，实现集群管理的基本功能。</p>
</li>
<li><p>kube-proxy:实现Kubernetes Service的通信和负载均衡机制的服务</p>
</li>
<li><p>容器运行时：负责本机的容器创建和管理</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看集群中的node</span><br><span class="line">kubectl get nodes</span><br><span class="line">#查看node的详细信息</span><br><span class="line">kubectl describe node &lt;node名称&gt;</span><br></pre></td></tr></table></figure>

<h5 id="3-命名空间"><a href="#3-命名空间" class="headerlink" title="3.命名空间"></a>3.命名空间</h5><p>​    命名空间属于Kubernetes集群范畴的资源对象，在一个集群里可以创建多个命名空间，每个命名空间都是相互独立的存在，属于不同命名空间的资源对象从逻辑上相互隔离。Master会自动创建两个命名空间，一个是默认(default)，一个是系统级(kube-system)。用户创建资源未指定命名空间，则默认存放在default命名空间中;而系统相关的资源对象如网络组件，DNS组件，监控类组件等，都会安装在kube-system命名空间中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##定义命名空间，在YAML文件定义名为development的命名空间：</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: development</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#创建命名空间后，可指定资源所属命名空间</span><br><span class="line">#以一个名为busybox的pod，并将其放入development这个命名空间中</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: busybox</span><br><span class="line">  namespace: development</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: busybox</span><br><span class="line">    command:</span><br><span class="line">      - sleep</span><br><span class="line">      - &quot;3600&quot;</span><br><span class="line">    name: busybox</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#通过--namespace=&lt;命名空间名&gt; 参数查看指定命名空间</span><br><span class="line">kubectl get pods --namespace=&lt;命名空间名&gt;</span><br><span class="line">#查看全部的命名空间</span><br><span class="line">kubectl get namespaces</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-应用类"><a href="#1-1-3-应用类" class="headerlink" title="1.1.3 应用类"></a>1.1.3 应用类</h4><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>在kubernetes中，Service是分布式集群架构的核心。一个service对象拥有如下关键特征：</p>
<ul>
<li><p>拥有唯一指定的名称(比如mysql-server)</p>
</li>
<li><p>拥有一个虚拟IP地址(ClusterIP地址)和端口号</p>
</li>
<li><p>能够提供某种远程服务能力</p>
</li>
<li><p>能够将客户端对服务的访问请求转发到一组容器应用上。</p>
</li>
</ul>
<p>如果service要提供外网服务，需要指定公共IP和NodePort，或者负载均衡器;</p>
<h5 id="NodePort-1"><a href="#NodePort-1" class="headerlink" title="NodePort"></a>NodePort</h5><p>系统会在Kubernetes集群中的每个Node上打开一个主机的真实端口，这样，能够访问Node的客户端就能通过这个端口访问到内部的Service了</p>
<h5 id="Service的ClusterIP地址"><a href="#Service的ClusterIP地址" class="headerlink" title="Service的ClusterIP地址"></a>Service的ClusterIP地址</h5><p>​    Service创建成功后，kubernetes会自动分配一个全局唯一的虚拟IP地址–ClusterIP地址，在service的整个生命周期内，ClusterIP地址都不会发生改变。<br>ClusterIP是一种虚拟IP地址，基于：<br>ClusterIP地址仅仅作用于kubernetes service对象本身，并由kubernetes管理和分配IP地址，与node和Master所在的物理网络完全无关。<br>因为没有”实体网络对象“来响应，所以ClusterIP地址无法被Ping通。ClusterIP地址只能与Service Port 组成一个具体的服务访问端点，单独的ClusterIP不具备TCP&#x2F;TP通信基础<br>ClusterIP属于kubernetes集群这个封闭空间，集群外节点访问通过其他方式完成。<br>如以myweb-svc.yaml为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service </span><br><span class="line">metadata:</span><br><span class="line">  name: myweb</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 8080</span><br><span class="line">  selector:</span><br><span class="line">    tier: frotend</span><br><span class="line">    </span><br><span class="line">服务端口定义为8080, 拥有tier=frotend标签的所有Pod实例都属于它</span><br><span class="line"></span><br><span class="line">kubectl get svc myweb -o yaml    查看ClusterIP</span><br></pre></td></tr></table></figure>

<h5 id="Service的外网访问问题"><a href="#Service的外网访问问题" class="headerlink" title="Service的外网访问问题"></a>Service的外网访问问题</h5><h5 id="kubernetes的三种IP"><a href="#kubernetes的三种IP" class="headerlink" title="kubernetes的三种IP"></a>kubernetes的三种IP</h5><ul>
<li><p>Node IP：Node的IP地址，是Kubernetes集群中真实存在的物理网络，所属网络的服务器都可通过这个网络直接通信。</p>
</li>
<li><p>Pod IP：Pod的IP地址，是每个Pod的IP地址</p>
</li>
<li><p>Service IP：Service的IP地址。</p>
</li>
</ul>
<p>Service的ClusterIP地址属于集群内的地址，无法在集群外直接使用。ModePort是解决集群外的应用访问集群内服务的直接，有效的常见做法。<br>以myweb-svc.yaml为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service </span><br><span class="line">metadata:</span><br><span class="line">  name: myweb</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: 8080</span><br><span class="line">      nodePort: 30001</span><br><span class="line">  selector:</span><br><span class="line">    app: myweb</span><br><span class="line"></span><br><span class="line">nodePort: 30001表明手动指定 myweb-server 的NodePort为30001</span><br></pre></td></tr></table></figure>

<p>Ingress资源对象实现机制基于Ngnix的支持虚拟主机的HTTP代理，可解决多个server共用一个端口，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: name-virtual-host-ingress</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: foo.bar.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          serviceName: service1</span><br><span class="line">          servicePort: 80</span><br><span class="line">  - host: bar.foo.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - backend:</span><br><span class="line">          serviceName: service2</span><br><span class="line">          servicePort: 80</span><br></pre></td></tr></table></figure>

<h5 id="Pod-1"><a href="#Pod-1" class="headerlink" title="Pod"></a>Pod</h5><p>pod是kubernetes最基本的操作单元，包含一个或多个紧密相关的容器，一个pod可以被一个容器化的环境看作应用层的”逻辑宿主机”；一个pod中的多个容器应用通常是紧密耦合的，pod在node上被创建，启动或者销毁；每个pod里运行着一个特殊的被称之为pause的容器，其他容器则为业务容器，这些业务容器共享Pause容器的网络栈和Volume挂载卷，因此他们之间通信和数据交换更为高效，在设计时我们可以充分利用这一特性将一组密切相关的服务进程放入同一个Pod中</p>
<p><img src="https://img30.360buyimg.com/ebookadmin/jfs/t1/137386/4/22021/69441/620eefbcEf18a8ff9/94d73fe5e124a6e0.jpg" alt="img"></p>
<p>​     Pod有两种：普通Pod和静态pod。<br>静态Pod：未存放在kubernetes的etcd中，而被存放在某个具体的node上的具体文件中，并切只能在此Node上启动，运行。<br>普通Pod：创建后会存放在etcd存储中，kubernetes Master会将其调度到某个具体的Node上绑定，该Pod被对应的Node上的kubelet进程实例化成一组相关的Docker容器并启动。<img src="https://img30.360buyimg.com/ebookadmin/jfs/t1/176702/25/27579/101563/620eefd4E7619f6d7/7815084c5255236d.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">######扩展</span><br><span class="line">#Event：是一个事件的记录，记录了事件的最早产生事件，最后重现事件，重复次数，发起者二，类型，以及导致此事件的原因等信息。Event通常会被关联到某个具体的资源对象上，是排查故障的重要参考信息。</span><br><span class="line">kubectk describe pod &lt;pod名称&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Pod及Pod周边对象示意图</p>
<p><img src="https://img30.360buyimg.com/ebookadmin/jfs/t1/215690/38/12706/79342/620eefbfE1d1a5b92/49a5fa3ffad4407e.jpg" alt="img"></p>
<h5 id="Volume-1"><a href="#Volume-1" class="headerlink" title="Volume"></a>Volume</h5><p>Volume是被挂载到Pod里的文件目录，是Pod中能够被多个容器访问的共享目录</p>
<h5 id="Label（标签）"><a href="#Label（标签）" class="headerlink" title="Label（标签）"></a>Label（标签）</h5><p>Label以key&#x2F;value的形式附加到各种对象上，如Pod、Service、RC、Node等，以识别这些对象，管理关联关系等，如Service和Pod的关联关系</p>
<p>常用的Label示例：</p>
<ul>
<li><p>版本标签：release: stable和 release: canary</p>
</li>
<li><p>环境标签：environment: dev，environment: qa和 environment: production</p>
</li>
<li><p>架构标签：tier: frontend，tier: backend 和 tier: middleware</p>
</li>
<li><p>分区标签：partition: customerA 和 partition: customerB</p>
</li>
<li><p>质量管控标签：track: daily 和track: weekly</p>
</li>
</ul>
<h5 id="Pod与Deployment"><a href="#Pod与Deployment" class="headerlink" title="Pod与Deployment"></a>Pod与Deployment</h5><p>Deployment可以由程序根据我们指定的模板自动创建指定数量的Pod实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1 </span><br><span class="line">kind: Deployment </span><br><span class="line">spec: </span><br><span class="line">  replicas: 2 </span><br><span class="line">  selector: </span><br><span class="line">    matchLabels: </span><br><span class="line">      app: myweb</span><br><span class="line">    template: </span><br><span class="line">      metadata: </span><br><span class="line">        labels: </span><br><span class="line">          app: myweb </span><br><span class="line">      spec:</span><br></pre></td></tr></table></figure>

<p>重要属性：</p>
<ul>
<li><p>replicas：Pod的副本数量</p>
</li>
<li><p>selector：目标Pod的标签选择器</p>
</li>
<li><p>temlpate：用于自动创建新Pod副本的模板</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">######扩展</span><br><span class="line">如若只有一个Pod副本实例，也需要用Deployment。Deployment除自动创建pod副本外，也可自动控制。如果Pod节点发生宕机事件，kubernetes检测到故，会自动创建一个新的podu对象，并调度到其他合适的节点，kuberentes会实时监控及权重目标POd副本数量，并与Deployment中声明的replicas数量保持一致</span><br></pre></td></tr></table></figure>

<p>以 myweb-deploy.yaml的 Deployment描述为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">   app: myweb</span><br><span class="line">  name: myweb </span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">   matchLabels:</span><br><span class="line">     app: myweb </span><br><span class="line">  template:</span><br><span class="line">   metadata:</span><br><span class="line">     labels:</span><br><span class="line">       app: myweb</span><br><span class="line">   spec:</span><br><span class="line">     containers:</span><br><span class="line">     - image: kubeguide/tomcat-app:v1</span><br><span class="line">       name: myweb</span><br><span class="line">       ports:</span><br><span class="line">       - containerPort: 8080</span><br><span class="line">       env:</span><br><span class="line">       - name: MYSQL_SERVICE_HOST</span><br><span class="line">         value: 10.233.7.142</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">##启动</span><br><span class="line">[root@k8s-master yuml]# kubectl create -f myweb-deploy.yaml</span><br><span class="line">#查看Deployment信息</span><br><span class="line">[root@k8s-master yuml]# kubectl get deployments</span><br><span class="line">NAME     READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">myweb    2/2     2            2           41h</span><br></pre></td></tr></table></figure>

<p>以上输出中各字段的含义解释如下<br>READY：replicas值定义的副本数量以及运行成功的数量<br>UP-TO-DATE：最新版本的Pod副本数量，用于指示在滚动升级的过程中，pod升级成功的数量<br>AVAILABLE：集群中存活的Pod数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看Deployment的名称与ReplicaSet的名称关系</span><br><span class="line">[root@k8s-master yuml]# kubectl get replicaset</span><br><span class="line">NAME                DESIRED   CURRENT   READY   AGE</span><br><span class="line">myweb-65864df57b    2         2         2       41h</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master yuml]# kubectl get pod</span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE</span><br><span class="line">myweb-65864df57b-9krqk    1/1     Running   0          41h</span><br><span class="line">myweb-65864df57b-sc2r8    1/1     Running   0          41h</span><br><span class="line"></span><br><span class="line">pod命名也是以Deployment对应的ReplicaSet对象的名称为前缀，更好的查明ReplicaSet对才能够创建了哪些pod</span><br></pre></td></tr></table></figure>

<p>Pod，Deployment与Service的逻辑关系：Service定义了一个服务的访问入口地址，前端的应用(Pod)通过这个入口地址访问其背后的一组由Pod副本组成的集群实例。Service与其后端Pod副本集群之间则通过Label Selector实现无缝对接，Deployment用于保证service的服务能力和服务质量始终符合预期标准<img src="https://img30.360buyimg.com/ebookadmin/jfs/t1/123338/19/22760/116889/620eefc2Ea59edea4/ef896049e835ba6e.jpg" alt="img"></p>
<h5 id="有状态的应用集群"><a href="#有状态的应用集群" class="headerlink" title="有状态的应用集群"></a>有状态的应用集群</h5><p>Deployment对象是用来实现无状态服务的多副本自动控制功能。<br>StatefulSet：可实现对有状态服务的控制</p>
<p>有状态集群的特殊共性：</p>
<ul>
<li>每个节点都有固定的身份ID,通过这个ID，集群中的成员可以相互发现并通信</li>
<li>集群的规模是比价固定的，集群规模不能随意变动</li>
<li>集群中的每个节点都是有状态的，通常会持久化数据到永久存储中，每个节点在重启后都要使用原有的持久化数据</li>
<li>如果磁盘损坏，则集群中的某个节点无法正常运行，集群功能受损</li>
</ul>
<p>StatefulSet特性：</p>
<ul>
<li>StatefulSet里的每个Pod都有稳定，唯一的网络标识。</li>
<li>StatefulSet控制的Pod副本的启停顺序是受控的</li>
<li>StatefulSet里的Pod采用稳定的持久化存储，通过PV或PVC来实现，删除Pod时默认不会删除与StatefulSet相关的存储卷</li>
</ul>
<p>Job(批量处理应用)<br>批量应用的特点：一个或多个进程处理一组数据，在这组数据处理完成后，批量任务结束。Kubernetes通过新的资源对象—-Job  实现<br>一个计算圆周率为例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch/v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: pi</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">	  -  name: pi</span><br><span class="line">          image: perl</span><br><span class="line">          command: [&quot;perl&quot;, &quot;-Mbignum=bpi&quot;, &quot;-wle&quot;, &quot;print bpi(100)&quot;]</span><br><span class="line">         restartPolicy: Never</span><br><span class="line">parallelism: 1</span><br><span class="line">completions: 5</span><br></pre></td></tr></table></figure>

<p>Jobs控制器提供两个控制并发的参数：completions和parallelism<br>completions表示需要运行任务数的总数<br>parallelism表示并发运行的个数，如设置parallelism为1，则依次运行任务</p>
<p>CronJob可周期性地执行某个任务</p>
<p>应用的配置问题</p>
<p>三种应用建模的资源对象<br>无状态服务的建模：Deployment<br>有状态集群的建模：StatefulSet<br>批处理应用的建模：Job</p>
<p>ConfigMap和Secret两个队形可解决应用在不同环境中需要修改配置的问题。</p>
<p>ConfigMap：是保存配置项（key&#x3D;value）的一个Map，是分布式系统中”配置中心“的独特实现之一。<br>具体做法如下：</p>
<ul>
<li>用户将配置文件的内容保存到ConfigMap中，文件名可作为key,value就是整个文件的内容，多个配置文件都可被放入同一个ConfigMap</li>
<li>在建模用户应用是，在Pod里将ConfigMap定义为特殊的Volume进行挂载。在pod被调度到某个具体Node上时，ConfigMap里的配置文件会被自动还原到本地目录下，然后映射到Pod里指定配置目录下。</li>
<li>在ConfigMap的内容发生修改后，kubernetes会自动重新获取ConfigMap的内容，并在目标节点上更新队形的文件</li>
</ul>
<p><img src="https://img30.360buyimg.com/ebookadmin/jfs/t1/112889/1/22361/210484/620ef00cEff91dafe/af3aff91b8ed5470.jpg" alt="img"></p>
<p>Secret：用于解决应用配置的问题，处理的是敏感信息的配置问题，如数据库用户名和密码等。</p>
<p>应用的运维问题</p>
<p> HPA：Pod横向自动扩容，即自动控制Pod属灵的增加或减少<br>原理：通过追踪分析指定Deployment控制的所有目标Pod的负载变化情况，来确定是否需要有针对性地调整目标Pod的副本数量。<br>HPA定义的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: autoscaling/v1</span><br><span class="line">kind: HorizontalPodAutoscaler</span><br><span class="line">metadata:</span><br><span class="line">  name: php-apache</span><br><span class="line">  namespace: default</span><br><span class="line">spec :</span><br><span class="line">  maxReplicas: 10</span><br><span class="line">  minReplicas: 1</span><br><span class="line">  scaleTargetRef:</span><br><span class="line">    kind: Deployment</span><br><span class="line">    name: php-apache</span><br><span class="line">  targetCPUUtilizationPercentage: 90</span><br></pre></td></tr></table></figure>

<p>VPA：垂直Pod自动扩缩容</p>
<p>存储类</p>
<p>存储类资源对象主要包括Volume,Persistent Volue, PVC和 StorageClass</p>
<p>Volume(存储卷)</p>
<p>Volume是pod中能够被多个容器访问的共享目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template:</span><br><span class="line">  metadata:</span><br><span class="line">    labels:</span><br><span class="line">      app: app-demo</span><br><span class="line">      tier: frontend</span><br><span class="line">    spec:</span><br><span class="line">      volumes:</span><br><span class="line">        - name: datavol</span><br><span class="line">          emptyDir: &#123;&#125;</span><br><span class="line">      containers:</span><br><span class="line">      - name: tomcat-demo</span><br><span class="line">      </span><br><span class="line">      image: tomcat</span><br><span class="line">      volumeMounts:</span><br><span class="line">        - mountPath: /mydata-data</span><br><span class="line">          name: datavol</span><br><span class="line">      imagePillPolicy: IfNotPresent</span><br></pre></td></tr></table></figure>

<p>1.emptyDir</p>
<p>emptyDir是Pod被分配到Node时创建。初始内容为空，kubernetes自动分配，无需指定宿主机的指定目录，当Pod从Node上移除时，emptyDir中的数据也被永久移除</p>
<p>emptyDir用途：</p>
<ul>
<li><p>临时空间，例如用于某些应用程序运行时所需的临时目录，且无需永久保留</p>
</li>
<li><p>长时间任务执行过程中使用的临时目录</p>
</li>
<li><p>一个容器需要从另一个容器中获取数据的目录</p>
</li>
</ul>
<ol start="2">
<li>hostPath</li>
</ol>
<p>hostPath为在Pod上挂载宿主机上的文件或目录，通常可以用于以下几方面。</p>
<ul>
<li>在容器引用程序生成日志文件需要永久保存时，可以使用宿主机的高速文件系统对其进行存储。</li>
<li>需要访问宿主机上Docker引擎内部数据结构的容器应用时，可以通过定义hostPath为宿主机&#x2F;var&#x2F;lib&#x2F;docker目录，使容器内部的应用可以直接访问Docker的文件系统</li>
</ul>
<p>在使用这种类型的Volume时，需要注意一下几点：</p>
<ul>
<li>在不同的Node上具有形同配置的Pod,可能会因为宿主机上的目录和文件不同，而导致对Volume上目录和文件的访问结果不一致</li>
<li>如果使用了资源配额管理，则kubernetes无法将hostPath在宿主机上使用的资源内如管理</li>
</ul>
<p>定义了宿主机的&#x2F;data为hostPath类型的Volume</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">- name: &quot;persistent-storage&quot;</span><br><span class="line">  hostPath:</span><br><span class="line">    path: &quot;/data&quot;</span><br></pre></td></tr></table></figure>

<p>3.公有云Volume</p>
<p>公有云厂商提供的相应的Volume产品</p>
<p>4.其他类型的Volume</p>
<ul>
<li>iscsi：将iscsi存储设备上的目录挂载到Pod中</li>
<li>nfs：将NFS Server上的目录挂载到Pod中</li>
<li>glusterfs：将开源的GlusterFS网络文件系统的目录挂载到Pod中</li>
<li>rbd：将Ceph快设备共享存储（Rados Block Device）挂载到Pod中</li>
<li>gitRepo：通过挂载一个空目录，并从git库克隆一个git repository以供Pod使用</li>
<li>configmap：将配置数据挂载为容器内的文件</li>
<li>secret：将Secret数据挂载为容器内的文件</li>
</ul>
<p>动态存储管理</p>
<p>Volume属于静态管理的存储，即先定义每个Volume,在将其挂载到Pod中，存在的弊端如下:<br>1)配置参数繁琐<br>2）预定义的静态Volume可能不符合目标应用的需求，比如容量问题，性能问题</p>
<p>动态存储的核心对象(概念)：Persistent Volume（简称PV），StorageClass，PVC</p>
<p>PV表示由系统台东创建一个存储卷，PV不被定义在Pod上，而是独立于Pod之外定义的<br>StorageClass用来描述和定义某种存储系统的特征</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: storage.k8s.io/v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">  name: standard</span><br><span class="line">provisioner: kubernetes.io/aws-ebs</span><br><span class="line">parameters:</span><br><span class="line">  type: gp2</span><br><span class="line">reclaimPolicy: Retain</span><br><span class="line">allowVolumeExpansion: true</span><br><span class="line">mountOptions:</span><br><span class="line">  - debug</span><br><span class="line">volumeBindingMode: Immediate</span><br><span class="line"></span><br><span class="line">provisioner代表了常见PV的第三方存储插件</span><br><span class="line">parameters是创建PV时必要的参数</span><br><span class="line">reclaimPolicy则表明了PV回收策略，回收策略包括删除或者保留</span><br><span class="line">StorageClass的名称会在PVC中出现</span><br></pre></td></tr></table></figure>

<p>PVC定义例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: claiml</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">  storageClassName: standard</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 30Gi</span><br><span class="line"> </span><br><span class="line">PVC:表示应用希望申请的PV规格。</span><br><span class="line">  accessModes(存储访问模式)，storageClassName(用那种storageClass来实现动态创建)及resources(存储的具体规格)</span><br></pre></td></tr></table></figure>

<p>以StorageClass和PVC为基础的动态PV管理机制，只需要在pod中引用PVC：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">    containers:</span><br><span class="line">    - name: myapp</span><br><span class="line">      image: tomcat:8.5.37-jre8</span><br><span class="line">      volumeMounts:</span><br><span class="line">        - name: tomcatedata</span><br><span class="line">          mountPath: &quot;/data&quot;</span><br><span class="line">     volumes:</span><br><span class="line">       - name: tomcatedata</span><br><span class="line">         persistentVolumeClaim:</span><br><span class="line">           claimName: claiml</span><br></pre></td></tr></table></figure>

<p>安全类</p>
<p>kubernetes用户分为两类<br>普通用户：如典型的kubectl命令行工具，基本上由指定的运维人员(集群管理员)使用<br>关键用户：Pod应用需要通过API Server查询，创建及管理其他相关资源对象，称为关键用户</p>
<p>RBAC：kubernetes设计了Service Account特殊的资源对象，代表Pod应用的账号，为Pod提供必要的身份认证，实现和完善了基于角色的访问控制权限系统。</p>
<p>Service Account：是不能全局使用，只能被它所在命名空间中的Pod使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get sa --all-namespaces</span><br></pre></td></tr></table></figure>

<p>Service Account是通过Secret来保存对应用户（应用）身份凭证</p>
<p>Role资源对象</p>
<p>Role资源对象包括：Role与ClusterRole 两种类型的角色<br>Role：局限于某个命名空间的角色由Role对象定义<br>ClusterRole：作用于整个Kubernetes集群范围内的角色则通过ClusterRole对象定义<br>下面是Role的例子，表示在命名空间default中定义一个Role对象，用于授予对Pod资源的读访问权限，绑定到该Role的用户则具有对Pod资源的get,watch和list权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  namespace: default</span><br><span class="line">  name: pod-reader</span><br><span class="line">rules:</span><br><span class="line">- apiGroups: [&quot;&quot;] # 空字符串”“表明使用 core API group</span><br><span class="line">  resources: [&quot;pods&quot;]</span><br><span class="line">  verbs: [&quot;get&quot;, &quot;watch&quot;, &quot;list&quot;]</span><br></pre></td></tr></table></figure>

<p>如何解决将Role与具体用户绑定（用户绑定）的问题。<br>例：在命名空间default中将”pod-reader“角色授予用户”Caden“,结合对应的Role的定义，表明这一授权将允许用户”Caden“从命名空间default中读取pod</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorizaion.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: read-pods</span><br><span class="line">  namespace: default</span><br><span class="line">subjects:</span><br><span class="line">- kind: User</span><br><span class="line">  name: Caden</span><br><span class="line"> apiGroup: rbac.authorization.k8s.io</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: pod-reader</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure>

<p>subjects(目标主体)：表示要授权的对象。是因为我们可以授权三类目标账号：Group（用户组），User（某个具体用户）和 Service Account（Pod应用所使用的账号）</p>
<p>NetworkPolicy（网络策略）：是网络安全相关的资源对象，用于解决用户应用之间的网络隔离和授权问题。是一种关于Pod间相互通信，以及Pod与其他网络端点间相互通信的安全规则设定。</p>
<p>安装指南</p>
<p>系统要求</p>
<p>安装kubernertes对软硬件的要求</p>
<table>
<thead>
<tr>
<th>软硬件</th>
<th>配置</th>
</tr>
</thead>
<tbody><tr>
<td>主机资源</td>
<td>集群规模：1~5   最低2C4G</td>
</tr>
<tr>
<td>etcd</td>
<td>V3版本及以上</td>
</tr>
<tr>
<td>Docker</td>
<td>19.03</td>
</tr>
</tbody></table>
<p>kubernetes需要容器运行时(Container Runtime Interface,CRI)的支持，目前官方支持的容器运行时包括：Docker，Containerd，CRI-O和frakti等。</p>
<p>具体配置的端口号(参考)</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>默认端口号</th>
</tr>
</thead>
<tbody><tr>
<td>API Server</td>
<td>8080（HTTP非安全端口号）<br />6443（HTTPS安全端口号）</td>
</tr>
<tr>
<td>Controller Manager</td>
<td>10252</td>
</tr>
<tr>
<td>Scheduler</td>
<td>10251</td>
</tr>
<tr>
<td>kubclct</td>
<td>10250<br />10255(只读端口号)</td>
</tr>
<tr>
<td>etcd</td>
<td>2379（供客户端访问）<br />2380（供etcd集群内部节点之间访问）</td>
</tr>
<tr>
<td>集群DNS服务</td>
<td>53（UDP）<br />53（TCP）</td>
</tr>
</tbody></table>
<p>安装前准备工作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1.1关闭防火墙、selinux、swap，重置iptables</span><br><span class="line"># 关闭selinux</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &#x27;/SELINUX/s/enforcing/disabled/&#x27; /etc/selinux/config</span><br><span class="line"># 关闭防火墙</span><br><span class="line">systemctl stop firewalld &amp;&amp; systemctl disable firewalld</span><br><span class="line"></span><br><span class="line"># 设置iptables规则</span><br><span class="line">iptables -F &amp;&amp; iptables -X &amp;&amp; iptables -F -t nat &amp;&amp; iptables -X -t nat &amp;&amp; iptables -P FORWARD ACCEPT</span><br><span class="line"># 关闭swap</span><br><span class="line">swapoff -a &amp;&amp; free –h</span><br><span class="line"></span><br><span class="line"># 关闭dnsmasq(否则可能导致容器无法解析域名)</span><br><span class="line">service dnsmasq stop &amp;&amp; systemctl disable dnsmasq</span><br><span class="line"></span><br><span class="line">1.2 k8s参数设置</span><br><span class="line"># 制作配置文件</span><br><span class="line">$ cat &gt; /etc/sysctl.d/kubernetes.conf &lt;&lt;EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_nonlocal_bind = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">vm.swappiness = 0</span><br><span class="line">vm.overcommit_memory = 1</span><br><span class="line">EOF</span><br><span class="line"># 生效文件</span><br><span class="line">$ sysctl -p /etc/sysctl.d/kubernetes.conf</span><br><span class="line"></span><br><span class="line">2. 使用kubespray部署集群（只操作某一个节点）</span><br><span class="line">2.1 配置免密</span><br><span class="line"># 1. 生成keygen（执行ssh-keygen，一路回车下去）</span><br><span class="line">$ ssh-keygen</span><br><span class="line"># 2. 查看并复制生成的pubkey</span><br><span class="line">$ cat /root/.ssh/id_rsa.pub</span><br><span class="line"># 3. 分别登陆到每个节点上，将pubkey写入/root/.ssh/authorized_keys</span><br><span class="line">$ mkdir -p /root/.ssh</span><br><span class="line">$ echo &quot;&lt;上一步骤复制的pubkey&gt;&quot; &gt;&gt; /root/.ssh/authorized_keys</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>kubeadm</p>
<p>kubeadm工具快速安装kubernetes集群</p>
<p>安装kubeadm</p>
<p>yum源配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes Repository</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg</span><br><span class="line">https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span><br><span class="line">exclude=kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line">官方源无法访问，可以配置国内源</span><br></pre></td></tr></table></figure>

<p>安装kubeadm,kubelet 和 kubectl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br></pre></td></tr></table></figure>

<p>启动kubelet服务，并设置开机自启</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start kubelet</span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure>

<p>修改kubeadm默认配置</p>
<p>​		kubeadm的初始化控制平面（init）命令和加入节点（join）命令均可通过指定的配置文件修改默认参数的值。kubeadm将配置文件以ConfigMap 形式保存到集群中，便于后续的查询和升级工作。kubeadm config子命令提供了对这组功能的支持</p>
<ul>
<li>kubeadm config print init-defaults：输出kubeadm init 命令默认参数的内容</li>
<li>kubeadm config print join-defaults：输出kubeadm join命令默认参数的内容</li>
<li>kubeadm config migrate：在新旧版本之间进行配置转换</li>
<li>kubeadm config images list：列出所需的镜像列表</li>
<li>kubeadm config images pull：来去镜像到本地</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">##获取默认的初始化参数文件</span><br><span class="line">kubeadm config print init-defaults &gt; init.default.yaml</span><br></pre></td></tr></table></figure>

<p>对生成的文件进行编辑，可以按需生成适合的配置，如，若需要自定义镜像的仓库地址，需要安装的kubernetes版本号及Pod的IP地址范围，则可以修改默认参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">......</span><br><span class="line">imageRepository: docker.io/dustise</span><br><span class="line">kubernetesVersion: 1.28.0</span><br><span class="line">networking:</span><br><span class="line">  podSubent: 192.168.0.0/16</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>下载Kubernetes相关镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#查看需要镜像列表 </span><br><span class="line">[root@localhost ~]# kubeadm config images list</span><br><span class="line">registry.k8s.io/kube-apiserver:v1.28.2</span><br><span class="line">registry.k8s.io/kube-controller-manager:v1.28.2</span><br><span class="line">registry.k8s.io/kube-scheduler:v1.28.2</span><br><span class="line">registry.k8s.io/kube-proxy:v1.28.2</span><br><span class="line">registry.k8s.io/pause:3.9</span><br><span class="line">registry.k8s.io/etcd:3.5.9-0</span><br><span class="line">registry.k8s.io/coredns/coredns:v1.10.1</span><br></pre></td></tr></table></figure>

<p>使用 kubeadm config images pull 命令或者 docker pull 命令下载镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config images pull --config-init-config.yaml</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://anthonywangjing.github.io/2025/02/25/kubernetes/" data-id="cm7jxcxvj0004r8o59p018izw" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/My-Blog/2025/02/25/CICD%E4%BB%8B%E7%BB%8D/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">CI/CD 介绍</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/My-Blog/categories/CI-CD/">CI/CD</a></li><li class="category-list-item"><a class="category-list-link" href="/My-Blog/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/My-Blog/categories/%E6%9D%82%E9%A1%B9/">杂项</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/My-Blog/tags/CI-CD/" rel="tag">CI&#x2F;CD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/My-Blog/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/My-Blog/tags/%E6%9D%82%E9%A1%B9/" rel="tag">杂项</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/My-Blog/tags/CI-CD/" style="font-size: 10px;">CI/CD</a> <a href="/My-Blog/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/My-Blog/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 10px;">杂项</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/My-Blog/archives/2025/02/">February 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/My-Blog/2025/02/25/kubernetes/">(no title)</a>
          </li>
        
          <li>
            <a href="/My-Blog/2025/02/25/CICD%E4%BB%8B%E7%BB%8D/">CI/CD 介绍</a>
          </li>
        
          <li>
            <a href="/My-Blog/2025/02/24/supervisor/">supervisor--进程管理控制工具</a>
          </li>
        
          <li>
            <a href="/My-Blog/2025/02/24/hxeo/">hexo 部署</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 豆豆鱼<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/My-Blog/" class="mobile-nav-link">Home</a>
  
    <a href="/My-Blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/My-Blog/js/jquery-3.6.4.min.js"></script>



  
<script src="/My-Blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/My-Blog/js/script.js"></script>





  </div>
</body>
</html>